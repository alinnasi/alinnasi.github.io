---
title: 正则表达式的“复杂”用法
date: 2017-07-17
category: regepx
---

正则表达式是每个开发者不得不掌握的工具，相信很多人都可以使用正则表达式做一些简单的匹配，比如`.`匹配任意一个字符，`.*`匹配任意多个字符...

除了简单的匹配规则，在这里我打算记录一些最近在工作中用到的，稍微复杂点的用法，方便以后查阅。

## 贪婪与非贪婪

贪婪即意味着，表达式总是匹配尽可能多的字符，而非贪婪则相反，后者总是匹配尽可能少的字符。

举个例子，比如现在有字符串`101010`，表达式`1.*1`是贪婪的，其中的`.*`将会一直匹配直到碰到最后的`1`，最终的匹配结果是`10001`。而如果使用非贪婪的表达式`1.*?1`，其中的`.*?`将会一直匹配直到碰到第二个`1`，因此最终的匹配结果是`101`。

以下是贪婪的正则表达式列表：

正则表达式  | 意义
:-------- | :-------
x*        | 匹配零个或多个x
x+        | 匹配一个或多个x
x?        | 匹配零个或一个x
x{n,m}    | 匹配n个到m个x
x{n,}     | 匹配n个到多个x
x{n}      | 匹配n个x

上面的6个贪婪的正则表达式，都有其非贪婪的版本，即在表达式后面加上`?`。如`x+`的非贪婪版本为`x+?`。对于第六个表达式而言，无论贪婪还是非贪婪，表达的意义都是一样的。

## 分组

谈到正则表达式，就不能不说到分组，分组能够帮我们从字符串中截取特定的字符串序列，比如有这么一个信息：`Name Jack, Age 18`，如果想拿到名字和年龄信息，Go程序如下：

```
package main

import (
    "regexp"
    "fmt"
)

func main() {
    s := "Name Jack, Age 18"

    reg, _ := regexp.Compile(`^Name (.+), Age (\d+)$`)
    if reg.MatchString(s) {
        subMatchs := reg.FindStringSubmatch(s)
        for i, subMatch := range subMatchs {
            fmt.Printf("%d. %s\n", i, subMatch)
        }
    }
}

/**
 * 输出：
 * 0. Name Jack, Age 18
 * 1. Jack
 * 2. 18
 */
```

除此之外，分组还有许多可以自定义的属性，比如设置一个非捕获的分组，该分组不会通过`FindStringSubmatch `返回：

正则表达式         | 意义
:----------------| :----------------
(表达式)          | 被编号且被捕获的分组，
(?P<命名>表达式)   | 被编号、被命名且被捕获的分组
(?:表达式)        | 非捕获的分组，相当于占位符的作用
(?:标记)          | 非捕获的分组，仅仅设置标记，该标记影响其后的分组
(?:标记:表达式)    | 非捕获的分组，设置标记影响当前分组

可用的标记有：

正则表达式       | 意义
:--------------| :-------
i              | 大小写不敏感，默认为false
m              | 让`^`和`$`匹配字符串的开头和结尾，而非行首和行尾，默认为false
s              | `.`可以匹配`\n`，默认为false
U              | 交换贪婪和非贪婪表达式的意义，默认为false

标记可以设置，也可以被清除。设置和清除的语法是：

正则表达式       | 意义
:--------------| :-------
xyz            | 设置xyz标记
-xyz           | 清除xyz标记
xy-z           | 设置xy标记，清除z标记